// COPYRIGHT Dassault Systemes 2009
//===================================================================
//
// JDAEPTMemoFactory.cpp
// Provide implementation to interface
//    JDAIPTMemoFactory
//
//===================================================================
//
// Usage notes:
//
//===================================================================
//  Apr 2009  Creation: Code generated by the CAA wizard  LuJun
//===================================================================
#include "JDAEPTMemoFactory.h"
#include "CATUnicodeString.h"
#include "CATIContainer.h"
#include "CATICatalog.h"
#include "CATCatalogFactoryServices.h"
#include "CATISpecObject.h"
#include "CATICkeParmFactory.h"
#include "CATICkeParm.h"
#include "CATISpecAttrAccess.h"
#include "CATIDescendants.h"
#include "JDAIPTContainer.h"
#include "CATISpecAttrKey.h"
#include "JDAIPTRoot.h"
#include "JDAIPTMemoParmEvents.h"

#include "JDAEPTMemoParmEvents.h"

#include "iostream.h"

 
CATImplementClass(JDAEPTMemoFactory,
                  DataExtension,
                  CATBaseUnknown,
                  JDAPTContainer );
 

//-----------------------------------------------------------------------------
// JDAEPTMemoFactory : constructor
//-----------------------------------------------------------------------------
JDAEPTMemoFactory::JDAEPTMemoFactory():
    CATBaseUnknown()
{
}

//-----------------------------------------------------------------------------
// JDAEPTMemoFactory : destructor
//-----------------------------------------------------------------------------
JDAEPTMemoFactory::~JDAEPTMemoFactory()
{
}
 
// Link the implementation to its interface
// ---------------------------------------



//TIE or TIEchain definitions
#include "TIE_JDAIPTMemoFactory.h"
TIE_JDAIPTMemoFactory( JDAEPTMemoFactory);


//Methods implementation

//-----------------------------------------------------------------------------
// Implements JDAIPTMemoFactory::CreateJDAPoint
//-----------------------------------------------------------------------------
HRESULT JDAEPTMemoFactory::CreateJDAPoint (double  iX , double  iY , double  iZ , JDAIPTMemo ** oPT)
{
	///--- Solution for Exercise : Applicative Feature Definition

	//cout <<"==> Now we are in JDAEPTMemoFactory::CreateJDAPoint  !" << endl;

	// Open the catalog
	// ----------------
	CATUnicodeString name = "JDPrdAppFeature.CATfct";
	CATUnicodeString id = "JDPrdAppClientId";
	CATIContainer_var spContainer = this;
	CATICatalog * piCatalog = NULL;

	HRESULT hr;
	hr = ::AccessCatalog(&name, &id, spContainer, &piCatalog);

	// Instanciate the object from the startup
	// ---------------------------------------
	CATISpecObject *piInstance = NULL;
	CATISpecObject *piStartup = NULL;
	CATUnicodeString featureType = "JDAPTMemo";

	//Retrieve startup
	if (SUCCEEDED(hr) && piCatalog) {
		hr = piCatalog->RetrieveSU ((CATBaseUnknown**)&piStartup, &featureType, "CATISpecObject");
		piCatalog->Release();		piCatalog = NULL;
	}
	else
		cout << "  ==> AccessCatalog error !" << endl;

	//Instanciate from startup
	if (SUCCEEDED(hr) && piStartup) {
		piInstance = piStartup->Instanciate(NULL_string, spContainer);
		piStartup->Release();		piStartup = NULL;
	}
	else
		cout << "  ==> RetrieveSU error !" << endl;

	 ///--- Solution for Exercise : Parameter Publication

	// Create a literal string to store the input text
	// ----------------------------------------------
	CATICkeParmFactory *piParmFactory = NULL;
	CATICkeParm_var spLitX = NULL_var;
	CATICkeParm_var spLitY = NULL_var;
	CATICkeParm_var spLitZ = NULL_var;
	CATISpecAttrAccess *piAccessOnFeature = NULL;
	CATIDescendants *piDescendantOnFeat = NULL;

	// Retrieve the param factory
	if (SUCCEEDED(hr)) {
		hr = this->QueryInterface(IID_CATICkeParmFactory, (void**)&piParmFactory);
	}

	//Instanciate a literal string
	if (SUCCEEDED(hr) && piParmFactory) { 
		spLitX = piParmFactory->CreateReal ("X", 0.0);
		spLitY = piParmFactory->CreateReal ("Y", 0.0);
		spLitZ = piParmFactory->CreateReal ("Z", 0.0);
		piParmFactory->Release();		piParmFactory = NULL;
	}
	else
		cout << "  ==> Get IID_CATICkeParmFactory error !" << endl;
	if ((spLitZ != NULL_var) && piInstance) {
		//Add this string to the Text attribute
		hr = piInstance->QueryInterface( IID_CATISpecAttrAccess, (void**) &piAccessOnFeature );
		if (SUCCEEDED(hr) && piAccessOnFeature) {
			//Set X attribute to CATISpecObject
			CATISpecAttrKey* piSpecAttrKey = NULL;
			piSpecAttrKey = piAccessOnFeature->GetAttrKey("X");
			piAccessOnFeature->SetSpecObject (piSpecAttrKey, spLitX);
			piSpecAttrKey->Release();  piSpecAttrKey = NULL;
			//Set Y attribute to CATISpecObject
			piSpecAttrKey = piAccessOnFeature->GetAttrKey("Y");
			piAccessOnFeature->SetSpecObject (piSpecAttrKey, spLitY);
			piSpecAttrKey->Release();  piSpecAttrKey = NULL;
			//Set Z attribute to CATISpecObject
			piSpecAttrKey = piAccessOnFeature->GetAttrKey("Z");
			piAccessOnFeature->SetSpecObject (piSpecAttrKey, spLitZ);
			//Release some pointer
			piSpecAttrKey->Release();  piSpecAttrKey = NULL;
			piAccessOnFeature->Release();			piAccessOnFeature = NULL;
		}
		else
			cout << "  ==> Get IID_CATISpecAttrAccess error !" << endl;
		//Aggregate it under the feature
		hr = piInstance->QueryInterface(IID_CATIDescendants, (void**) &piDescendantOnFeat);
		if (SUCCEEDED(hr) && piDescendantOnFeat) {
			piDescendantOnFeat->Append(spLitX);
			piDescendantOnFeat->Append(spLitY);
			piDescendantOnFeat->Append(spLitZ);
			piDescendantOnFeat->Release();
			piDescendantOnFeat = NULL;
		}
		else
			cout << "  ==> Get CATIDescendants error !" << endl;
	}
	else
		cout << "  ==> Get Instanciate error !" << endl;
	///------- End Solution: Parameter Publication

	// Set the attributes (text and geometry)
	// -------------------
	if (SUCCEEDED(hr) && piInstance) {
		hr = piInstance->QueryInterface(IID_JDAIPTMemo, (void**)oPT);
	}
	if (SUCCEEDED(hr) && (*oPT)) {
		hr = (*oPT)->SetX(iX);
		hr = (*oPT)->SetY(iY);
		hr = (*oPT)->SetZ(iZ);
		//no release because piMemo is our return value
	}
	else
		cout << "  ==> Get IID_JDAIPTMemo error !" << endl;
	// Update the feature
	// -----------------
	if (SUCCEEDED(hr) && piInstance) {
		piInstance->Update();

		//AddSubscription for my feature
		JDAIPTMemoParmEvents_var spParmEvent=piInstance;
		if( !!spParmEvent ) {
			spParmEvent->AddSubscribe(spLitX);
			spParmEvent->AddSubscribe(spLitY);
			spParmEvent->AddSubscribe(spLitZ);
		}

	}
	// Retrieve the root object for annotations
	// ------------------------------
	JDAIPTRoot *piAnoRoot = NULL;
	JDAIPTContainer *piAnoContainer = NULL;
	hr = this->QueryInterface(IID_JDAIPTContainer, (void**)&piAnoContainer);
	if (SUCCEEDED(hr) && piAnoContainer) {
		hr = piAnoContainer->GetRoot(&piAnoRoot);
		piAnoContainer->Release();		piAnoContainer = NULL;
	}
	else
		cout << "  ==> Get IID_JDAIPTContainer error !" << endl;

	// Append the object to the root
	// -----------------------------
	if (SUCCEEDED(hr) && piAnoRoot && piInstance) {

		// Set automatic naming
		// Note: automatic naming works only if there is a component 
		//       aggregation between the father and the named object
		CATISpecObject_var spSpecOnRoot = piAnoRoot;

		if (spSpecOnRoot != NULL_var) {
			piInstance->SetAutoNameFather(spSpecOnRoot);
		}
	  
		//Refresh of the view and the graph is done in AddChild
		piAnoRoot->AddChild(piInstance);

		piAnoRoot->Release();
		piAnoRoot = NULL;

		piInstance->Release();
		piInstance = NULL;
	}
	else
		cout << "  ==> Get piAnoRoot error !" << endl;

	//cout <<"==> Now end JDAEPTMemoFactory::CreateJDAPoint  !" << endl;

   return hr;
}

